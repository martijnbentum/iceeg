import glob
import pandas as pd
import path

class log:
	'''Aggregate information about start/end times in the experiment.

	.fid2dur dictionary which maps file id to n seconds
	.fid2sid dictionary which maps file id to speaker id
	.marker2fidlist dictionary which maps a marker to file ids which make up the experimental audio file
	.marker2wav dictionary which maps a marker to experimental audio filename

	.answer Panda df containing: 
		-answers to (yes/no) comprehension questions asked after each block
	.log Panda df containing:
		-filenames of the experimental audio files
		-participant number and age (should add gender)
		(should be extended with answer accuracy and temperature and humidety)
	'''
	
	def __init__(self, pp_id = None,exp_type = None):
		'''Aggregate information about start/end times of events in the experiment.
		
		Keywords:
		pp_id = participant id (1-48) int
		exp_type = experimental type (k/o/ifadv) reflects register of speech in audio file str
		'''

		print('loading log object with:',pp_id,exp_type,path.data)
		self.pp_id = pp_id
		self.exp_type = exp_type
		self.session = None
		self.log = self.read_log()
		self.answer = self.read_answer()
		self.set_start_end_times() # start end times experiment
		self.load_fnlist()
		self.marker2wavname_dict()
		self.marker2fidlist_dict()
		self.fid2sid_dict()
		self.fid2dur_dict()

	def __str__(self):
		m = 'log filename:\t\t' + str(self.log_fn) + '\n'
		m += 'answer filename:\t' + str(self.answer_fn) + '\n'
		return m


	def exp_time2pd_time(self,t):
		'''Transform epoch time to pandas library recognized time format.'''
		if t == 'NA' or t == 'na':
			return None
		t = t.split('-')
		t = '2017 '+ ' '.join(t[:2]) + ' ' + ':'.join(t[2:-1]) + '.' + t[-1]
		# replace dutch for englisch abbrv
		t = t.replace('mrt','mar').replace('mei','may') 
		return pd.to_datetime(t)


	def set_start_end_times(self):
		'''Set the start and end date of the experiment and calculates duration.'''
		if not self.log_fn:
			return None
		self.start_exp = self.exp_time2pd_time(self.log.start_time[0])
		self.end_exp = self.exp_time2pd_time(self.log.end_time.iloc[-1])
		self.duration = self.end_exp - self.start_exp
		for i, t in enumerate(self.log.start_time):
			self.log.loc[i,('start_time')] = self.exp_time2pd_time(t)
		for i, t in enumerate(self.log.end_time):
			 self.log.loc[i,('end_time')] = self.exp_time2pd_time(t)
		self.log['duration'] = self.log.end_time - self.log.start_time
		
	
	def read_log(self):
		'''Read the log output generated by presentation.'''
		# contains trial ids, timestamps, marker codes and audio stimulus fn
		if not self.pp_id or not self.exp_type:
			self.log_fn = None
			print("need pp_id and exp_type")
			return None
		self.find_log_filename()
		if self.log_fn == None:
			return None
		print('loading log: \t\t',self.log_fn)
		names=['pp_id','name','handedness','age','session','exp_type', \
			'filename','marker','ctime','utime','wav_duration','answer_fn', \
			'block','start_time','end_time']
		log = pd.read_table(filepath_or_buffer=self.log_fn,sep='\s+',names = names)
		self.session = log.session[0]
		return log 


	def read_answer(self):
		'''Read the answer output generated by presentation.
		Contains question ids, answers and timestamps and marker codes
		'''
		if not self.pp_id or not self.exp_type:
			self.answer_fn= None
			self.session = None
			print("need pp_id and exp_type")
			return None
		self.find_answer_filename()
		if self.answer_fn == None:
			return None
		print('loading answers: \t',self.answer_fn)
		names=['pp_id','name','handedness','age','session','exp_type', \
			'block','answer','ctime','tnumber','smarker','amarker', \
			'qnumber','log_name','date','time']
		answer = pd.read_table(filepath_or_buffer = self.answer_fn,sep='\s+', \
		names =names)
		self.session = answer.session[0]
		return answer
	

	def find_log_filename(self):
		'''Find the filename based on pp_id and exp type, sets to none if it fails.'''
		temp = glob.glob(path.data + 'log/pp' +str(self.pp_id) \
			+ '_' + self.exp_type + '_log*.txt')
		try:
			self.log_fn = temp[0]
		except:
			print('Could not find log file with:',self.pp_id,self.exp_type,temp)
			self.log_fn = None
	

	def find_answer_filename(self):
		'''Finds the filename based on pp_id and exp type, sets to none if it fails.'''
		temp = glob.glob(path.data + 'log/pp' +str(self.pp_id) \
			+ '_' + self.exp_type + '_answers*.txt')
		try:
			self.answer_fn = temp[0]
		except:
			print('Could not find answer file with:',self.pp_id,self.exp_type,temp)
			self.answer_fn = None
		

	def load_fnlist(self):
		if self.exp_type == 'ifadv':
			names = 'speaker1,speaker2,fid,order,filename'.split(',')
		else:
			names = 'speaker1,fid,order,filename'.split(',')
		f = path.data + '/fnlist_'+self.exp_type+'.txt'
		self.fnlist = pd.read_table(filepath_or_buffer=f,sep = '\t',names =names)


	def marker2wavname_dict(self):
		'''Create a dict with markers as keys and wav_name as values.'''
		print("Creating marker_wav dict:\t marker -> wav_name")
		#log is pandaframe and the list of filenames is used to acces columns
		#as matrix turns into dtype object (numpy?) and list into a list of list
		self.marker2wav = dict(list(self.log[['marker','filename']].values))

	
	def marker2fidlist_dict(self):
		'''Create a dict with markers as keys and file id as values.'''
		self.marker2fidlist = {}
		for marker in self.marker2wav.keys():
			wav_name = self.marker2wav[marker]
			temp = self.fnlist[self.fnlist['filename'] == wav_name]
			self.marker2fidlist[marker] = list(temp['fid'].values)

	def fid2sid_dict(self):
		'''Create a dict with file id as keys and speaker id as values.'''
		self.fid2sid = {}
		for marker in self.marker2fidlist.keys():
			fids = self.marker2fidlist[marker]
			for fid in fids:
				temp = self.fnlist[self.fnlist['fid'] == fid]
				if self.exp_type == 'ifadv':
					# THIS IS A HACK NOT USING DATA FROM FILE
					self.fid2sid[fid] = ['spreker1','spreker2']
				else:
					self.fid2sid[fid] = list(temp['speaker1'].values)
	
	def fid2dur_dict(self):
		'''Create dict that maps fid to duration of corresponding wav file.
		(also contains info on the location of the wav file)
		'''
		if self.exp_type == 'o':
			self.fid_duration = [line.split('\t') for line in open(path.data+'/fids_duration_o.txt')]
		if self.exp_type == 'k':
			self.fid_duration = [line.split('\t') for line in open(path.data+'/fids_duration_k.txt')]
		if self.exp_type == 'o' or self.exp_type == 'k':
			self.fid2dur = dict([[l[0],int(float(l[1])*1000)] for l in self.fid_duration])

			



		
