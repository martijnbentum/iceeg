#adapted from combine artefacts

import bad_epoch
import check_artifact_channel_length as cacl
import check_artifact_length as cal
import copy
import glob
import notes
import numpy as np
import os
import path
import utils
import windower
import xml_handler

class compare_annotation():
	'''Object to compare automatic and manually corrected annotations (based on the automatic ones).

	Automatic annotations were generated by convolutional neural network (cnn) trained on
	bad epoch and a cnn trained on bad channels.

	Manual annotations are corrections to the automatic annotations

	There are two type of annotations, bad epoch and bad channels
	a bad epoch is a section where most channels are bad
	a bad channel is a section where a specific channel is bad (and typically most others are not)
	'''
	def __init__(self, name, fo = None):
		'''Create compare object for a specific block.
		name 			name of block
		fo 				fid2ort object, speeds up loading of blocks
		'''
		if name == '-': return
		f = path.bads_annotations + 'bads_'+name+'.xml'
		self.epoch_id = 1
		self.name = name
		self.fo = fo

		self.b = utils.name2block(name,fo)
		self.read_all()
		self.block_duration = utils.load_100hz_numpy_block(name).shape[-1] * 10
		self.compute_annotation_difference()
		self.set_durations()
		

	def __str__(self):
		m = 'name\t\t'+self.name +'\n'
		m += 'nbe\t\t'+str(self.nbe)+'\n'
		m += 'nbc\t\t'+str(self.nbc)+'\n'
		m += 'be_annot\t'+str(self.be_annotations)+'\n'
		m += 'bc_annot\t'+str(self.bc_annotations)+'\n'
		m += 'artifact ch\t' + '\n\t\t'.join([k+'\t'+str(v) for k,v in sorted(self.artifact_channels.items(), key=lambda x: x[1],reverse=True)]) + '\n'
		m += 'ch threshold\t'+str(self.ch_threshold)+'\n'
		m += 'remove ch\t'+' '.join(self.remove_ch)+'\n'
		m += 'usability\t'+ self.usability+'\n'
		m += 'block dur\t'+str(self.block_duration)+'\n'
		m += 'clean dur\t'+ str(self.clean_duration) + '\n'
		m += 'artifact dur\t'+ str(self.artifact_duration) + '\n'
		m += 'clean perc\t'+ str(round(self.clean_perc,3)) + '\n'
		m += 'artifact perc\t'+ str(round(self.artifact_perc,3)) + '\n'
		return m

	def __repr__(self):
		m = 'b\t'+self.name 
		# m += '\t' + self.usability
		m += '\tbe:' + ' '.join(map(str,self.be_dif_total))
		m += '   \tbc:' + ' '.join(map(str,self.bc_dif_total))
		return m

	def read_bad_epochs(self):
		'''read the bad epochs from file, should be the corrected automatic annotations.
		'''
		self.auto_f_be = get_xml_filename(self.name,bad_type='bad_epoch',correction_type= 'auto')
		self.man_f_be = get_xml_filename(self.name,bad_type='bad_epoch',correction_type='manual')
		self.auto_be = xml_handler.xml_handler(filename = self.auto_f_be,artifact_type = 'bad_epoch')
		self.man_be = xml_handler.xml_handler(filename = self.man_f_be,artifact_type = 'bad_epoch')
		self.auto_be.xml2bad_epochs()
		self.man_be.xml2bad_epochs()
		self.auto_be.bad_epochs = [be for be in self.auto_be.bad_epochs if be.annotation != 'clean']
		self.man_be.bad_epochs = [be for be in self.man_be.bad_epochs if be.annotation != 'clean']

	def read_bad_channels(self):
		'''read the bad channel from file, should be the corrected automatic annotations.
		'''
		self.auto_f_bc = get_xml_filename(self.name,bad_type='bad_channel',correction_type='auto')
		self.man_f_bc = get_xml_filename(self.name,bad_type='bad_channel',correction_type='manual')
		self.auto_bc = xml_handler.xml_handler(filename = self.auto_f_bc,artifact_type = 'bad_channel')
		self.man_bc = xml_handler.xml_handler(filename = self.man_f_bc,artifact_type = 'bad_channel')
		self.auto_bc.xml2bad_channels()
		self.man_bc.xml2bad_channels()

	def read_note(self):
		'''Read the note of the block, stating the usability of the block.
		'''
		self.n = notes.note(self.name)

	def read_all(self):
		'''Read all xml files corresponding to this block.'''
		self.read_bad_epochs()
		self.read_bad_channels()
		self.read_note()

	def match_annots(self):
		'''Match all automatic annotations to the manual corrected ones.
		also find the missing annotations (not present in manual, should not happen) and extra
		annotation that were added during manual correction.
		'''
		#artefact, bad epochs
		man_bes, auto_bes = self.man_be.bad_epochs,self.auto_be.bad_epochs
		ma, mi, ex = match_man_auto_annot(man_bes,auto_bes)
		self.matched_bad_epochs, self.missing_bad_epochs, self.extra_bad_epochs = ma,mi,ex
		#channel artefacts, bad channels
		man_bcs, auto_bcs = self.man_bc.bad_channels,self.auto_bc.bad_channels
		ma, mi, ex = match_man_auto_annot(man_bcs,auto_bcs)
		self.matched_bad_channels, self.missing_bad_channels, self.extra_bad_channels = ma,mi,ex

		
	def compute_annotation_difference(self):
		'''Compute how much extra bad epoch and bad channel and how much was removed
		compared to the automatic annotations.
		'''
		if not hasattr(self,'matched_bad_epochs'):self.match_annots()
		if not hasattr(self,'be_nextra'): self.handle_extras()
		for annot_type in 'be','bc':
			output =[]
			matched = self.matched_bad_epochs if annot_type == 'be' else self.matched_bad_channels
			for m in matched:
				man,auto = m
				output.append(compute_annotation_difference(man,auto))
			extra_dif = self.be_extra_dif if annot_type == 'be' else self.bc_extra_dif
			output.append(extra_dif)
			setattr(self,annot_type +'_dif',output)
			total = np.sum(np.array(output),0)
			setattr(self,annot_type +'_dif_total',total)

			
	def handle_extras(self):
		extra,others = self.extra_bad_epochs, self.man_be.bad_epochs
		self.be_nextra = len(extra)	
		self.be_extra_overlap, self.be_extra_noverlap = check_overlap_extra(extra,others)
		self.be_extra_duration = annots2duration(extra)
		self.be_extra_dif = (self.be_extra_duration,0,self.be_extra_duration,self.be_extra_overlap)
		extra,others = self.extra_bad_channels, self.man_bc.bad_channels
		self.bc_nextra = len(extra)	
		self.bc_extra_overlap, self.bc_extra_noverlap = check_overlap_extra(extra,others)
		self.bc_extra_duration = annots2duration(extra)
		self.bc_extra_dif = (self.bc_extra_duration,0,self.bc_extra_duration,self.bc_extra_overlap)
				

	def set_durations(self):
		self.auto_be_bad= annots2duration(self.auto_be.bad_epochs)
		self.man_be_bad= annots2duration(self.man_be.bad_epochs)

		self.auto_be_clean= self.block_duration - self.auto_be_bad
		self.man_be_clean= self.block_duration - self.man_be_bad

		self.auto_bc_bad= annots2duration(self.auto_bc.bad_channels)
		self.man_bc_bad= annots2duration(self.man_bc.bad_channels)

		self.auto_bc_clean= self.block_duration*25 - self.auto_bc_bad
		self.man_bc_clean= self.block_duration*25 - self.man_bc_bad
		

	def make_info(self): # WORK IN PROGRESS, OLD CODE
		'''creates aggregate information for the block about channel and epoch artifacts
		and the durations of those artifacts.
		'''
		self.usability = self.n.general_notes['usability']
		self.nbc= len(self.bc.bad_channels)
		self.nbe= len(self.be.bad_epochs)
		self.clean_duration = sum([c.duration for c in self.bads if c.annotation =='clean'])
		self.artifact_duration = sum([c.duration for c in self.bads if c.annotation =='artifact'])
		self.clean_perc= self.clean_duration / self.block_duration
		self.artifact_perc= self.artifact_duration / self.block_duration

	def save(self):
		'''Write the object to xml.
		'''
		x = xml_handler.xml_handler(bads=self,artifact_type='bads')
		x.bads2xml()
		x.save(path.bads_annotations + 'bads_' + self.name + '.xml')


def read_notes(exp):
	'''Read all notes of all block of all participants OBSOLETE.
	'''
	names = read_names(exp)
	return [notes.note(name) for name in names]

def read_names(exp):
	'''Read all names of each block of all participants of one experiment.'''
	return [line for line in open(path.data+'names-sorted-duration_'+exp).read().split('\n') if line]


def get_xml_filenames(name):
	'''Get the filenames of the xml files for the corrected automatic 
	epoch and channel annotations.'''
	output = []
	output.append( get_xml_filename(name,'bad_epoch','manual') )
	output.append( get_xml_filename(name,'bad_channel','manual') )
	output.append( get_xml_filename(name,'bad_epoch','auto') )
	output.append( get_xml_filename(name,'bad_channel','auto') )
	return output

def get_xml_filename(name,bad_type = 'bad_epoch', correction_type = 'manual'):
	'''Get filename of the xml file for bad epoch or channel.'''
	if bad_type == 'bad_epoch': 
		if correction_type == 'manual': directory = path.corrected_artifact_cnn_xml
		elif correction_type == 'auto': directory = path.artifact_cnn_xml
	elif bad_type == 'bad_channel': 
		if correction_type == 'manual': directory = path.corrected_ch_cnn_xml
		elif correction_type == 'auto': directory = path.artifact_ch_cnn_xml
	temp = glob.glob(directory + '*' + name + '.xml')
	if temp != []: 
		if len(temp) > 1: print('found multiple files ERROR',temp)
		filename = temp[0]
		return filename
	else: print('could not find file',name)


def match_man_auto_annot(man_annots,auto_annots,verbose=False):
	'''Match epochs from the manually corrected and not corrected annotations (auto).
	return a list of tuples with matched epochs a list of epochs not present in manual correct
	and a list with extra manual annotations (not present in the automatic annotations.
	'''
	extra = man_annots[:]
	indices = []
	matched, missing = [],[]
	for auto in auto_annots:
		found = False
		for i,man in enumerate(extra):
			if man.epoch_id == auto.epoch_id:
				matched.append((man,auto))
				found = True
				break
		if not found: missing.append(auto)
		else: extra.pop(i)
	if verbose: print('matched:',len(matched),'missing:',len(missing),'extra:',extra)
	return matched,missing,extra

def compute_annotation_difference(man,auto, verbose = False):
	'''Compute the difference between manual and auto corrected annotation
	man 		1 epoch, manually corrected annotation
	auto 		1 epoch, not manually corrected (generated by cnn model)
	assumes corresponding man and auto annotation and compute how much is added and/ or removed
	overlap is also computed, match is based on epoch_id
	'''
	if man.epoch_id!=auto.epoch_id:raise ValueError(man.epoch_id,auto.epoch_id,'epoch id do not match')
	if man.correct == 'incorrect': return 0,man.duration,man.duration,0
	mst,met = man.st_sample, man.et_sample
	ast,aet = auto.st_sample, auto.et_sample
	# overlap = True if windower.compute_overlap(mst,met,ast,aet) == 0 else False
	overlap = windower.compute_overlap(mst,met,ast,aet) 
	#boundary of manual corrections was shifted by 1 sample, corrected below
	start_dif = auto.st_sample - man.st_sample 
	end_dif = man.et_sample - auto.et_sample
	removed,added = 0,0
	if start_dif > 0: added += start_dif
	else: removed += start_dif
	if end_dif > 0: added += end_dif
	else: removed += end_dif
	if verbose:
		print('id:',man.epoch_id,'start_dif:',start_dif,'end_dif:',end_dif,'added:',added,'removed:',removed)
	diff = added + (removed*-1)
	return added,removed,diff,overlap
		

def check_overlap_extra(extras,others, verbose = False):
	'''Check the overlap of annotations added in the manual correction (these were not generated by
	the cnn model.'''
	overlap,noverlap = 0,0
	for b in extras:
		annot_type = 'bc' if hasattr(b,'channel') else 'be'
		for ob in others + extras:
			if b == ob: continue
			overlap += windower.compute_overlap(b.st_sample,b.et_sample,ob.st_sample,ob.et_sample)
			noverlap += 1
	if verbose: print('annotation type:',annot_type,'overlap:',overlap)
	return overlap, noverlap

def annots2duration(annots, check_correct = True):
	'''Return the duration of all annotations in a list of annotations, only sums correct annotations.
	only manual corrected annotations can be incorrect.'''
	if check_correct:
		return sum([a.duration for a in annots if a.correct != 'incorrect'])
	else:
		return sum([a.duration for a in annots])

