import glob
import numpy as np
import pandas as pd
import re
# PATH = '/Users/Administrator/storage/EEG_DATA_ifadv_cgn/'
PATH = '../'


class experiment:
	def get_id(self):
		return self.pp_id

	def __init__(self, pp_id = None,exp_type = None,path = None):
		print('leading experiment with: ',pp_id,exp_type,path)
		if not path:
			self.path = PATH
		self.pp_id = pp_id
		self.exp_type = exp_type
		self.session = None
		self.log = self.read_log()
		self.answer = self.read_answer()
		self.read_vmrk()
		self.vmrk2events()# creates an np array events from 1 or more vmrk lists
		self.vmrk2dict() # creates a dict with markers as keys and sample numbers as values
		self.set_start_end_times() # start end times experiment


	def __str__(self):
		# print relevant info 
		m = 'Participant number:\t' + str(self.pp_id) + '\n'
		m += 'Experiment name:\t' + str(self.exp_type) + '\n'
		m += 'Session number: \t' + str(self.session) + '\n'
		m += 'Start experiment:\t' + str(self.start_exp) + '\n'
		m += 'End experiment:\t\t' + str(self.end_exp) + '\n'
		m += 'Duration:\t\t' + str(self.duration).split(' ')[-1] + '\n'
		m += 'log filename:\t\t' + str(self.log_fn) + '\n'
		m += 'answer filename:\t' + str(self.answer_fn) + '\n'
		m += 'vmrk filename:\t\t' + str(self.vmrk_fn) + '\n'
		fields = ('pp_id exp_type session log answer vmrk ' \
			'events marker_dict start_exp end_exp duration ' \
			'log_fn answer_fn vmrk_fn').split(' ')
		m += '\nFIELDS:\n' + '\n'.join(fields)
		return m
		

	def exp_time2pd_time(self,t):
		# transforms times to pandas library recognized time format
		if t == 'NA' or t == 'na':
			return None
		t = t.split('-')
		t = '2017 '+ ' '.join(t[:2]) + ' ' + ':'.join(t[2:-1]) + '.' + t[-1]
		t = t.replace('mrt','mar').replace('mei','may') # replace dutch for englisch abbrv
		return pd.to_datetime(t)


	def set_start_end_times(self):
		# sets the start and end date of the experiment and calculates duration
		if not self.log_fn:
			return None
		self.start_exp = self.exp_time2pd_time(self.log.start_time[0])
		self.end_exp = self.exp_time2pd_time(self.log.end_time.iloc[-1])
		self.duration = self.end_exp - self.start_exp
		for i, t in enumerate(self.log.start_time):
			self.log.loc[i,('start_time')] = self.exp_time2pd_time(t)
		for i, t in enumerate(self.log.end_time):
			 self.log.loc[i,('end_time')] = self.exp_time2pd_time(t)
		self.log['duration'] = self.log.end_time - self.log.start_time
		
	
	def read_log(self):
		# read the log output generated by presentation
		# contains trial ids, timestamps, marker codes and audio stimulus fn
		if not self.pp_id or not self.exp_type:
			self.log_fn = None
			print("need pp_id and exp_type")
			return None
		self.find_log_filename()
		if self.log_fn == None:
			return None
		print('loading log: \t\t',self.log_fn)
		names=['pp_id','name','handedness','age','session','exp_type', \
			'filename','marker','ctime','utime','wav_duration','answer_fn', \
			'block','start_time','end_time']
		log = pd.read_table(filepath_or_buffer=self.log_fn,sep='\s+',names = names)
		self.session = log.session[0]
		return log 


	def read_answer(self):
		# read the answer output generated by presentation 
		# contains question ids, answers and timestamps and marker codes
		if not self.pp_id or not self.exp_type:
			self.answer_fn= None
			self.session = None
			print("need pp_id and exp_type")
			return None
		self.find_answer_filename()
		if self.answer_fn == None:
			return None
		print('loading answers: \t',self.answer_fn)
		names=['pp_id','name','handedness','age','session','exp_type', \
			'block','answer','ctime','tnumber','smarker','amarker', \
			'qnumber','log_name','date','time']
		answer = pd.read_table(filepath_or_buffer = self.answer_fn,sep='\s+', \
		names =names)
		self.session = answer.session[0]
		return answer
	

	def find_log_filename(self):
		# finds the filename based on pp_id and exp type, sets to none if it fails
		temp = glob.glob(self.path + 'log/pp' +str(self.pp_id) \
			+ '_' + self.exp_type + '_log*.txt')
		try:
			self.log_fn = temp[0]
		except:
			print('Could not find log file with:',self.pp_id,self.exp_type,temp)
			self.log_fn = None
	

	def find_answer_filename(self):
		# finds the filename based on pp_id and exp type, sets to none if it fails
		temp = glob.glob(self.path + 'log/pp' +str(self.pp_id) \
			+ '_' + self.exp_type + '_answers*.txt')
		try:
			self.answer_fn = temp[0]
		except:
			print('Could not find answer file with:',self.pp_id,self.exp_type,temp)
			self.answer_fn = None
		

	def find_vmrk_filename(self):
		# finds the filename based on pp_id and exp type, sets to none if it fails
		# will set n eeg recordings according to n matches it finds
		# sometimes 1 session was recorded in multiple file (because of battery failure)
		pp_id = str(self.pp_id)
		fn = glob.glob(self.path + 'EEG/pp*' + pp_id + '_' \
			+ self.exp_type + '*.vmrk')
		matches = []
		for f in fn:
			temp = re.match(r".*pp0*("+pp_id+")_.*\.vmrk", f)
			if temp != None:
				matches.append(temp.string)
		# handle filename based on the number of matching files found
		if len(matches) == 0:
			print('Could not find vmrk file with pp_id',self.pp_id,fn)
			self.vmrk_fn = None
			self.n_eeg_recordings = 0
		elif len(matches) == 1:
			self.vmrk_fn = matches[0]
			self.n_eeg_recordings = 1
		else:
			self.vmrk_fn = matches
			self.n_eeg_recordings = len(matches)


	def read_vmrk(self):
		# reads in the marker file and deals with multiple recording in 1 session
		if not self.pp_id or not self.exp_type:
			print("need pp_id and exp_type")
			self.vmrk_fn= None
			self.session = None
			self.vmrk = None
			return None
		self.find_vmrk_filename()						
		print('loading vmrk: \t\t',self.vmrk_fn)
		if self.n_eeg_recordings == 1:
			temp = [line.split(',') for line in open(self.vmrk_fn).read().split('\n')]
			self.vmrk= [line for line in temp if line[0][:len('Mk')] == 'Mk']
		elif self.n_eeg_recordings > 1:
			self.vmrk = []
			for vmrk_fn in self.vmrk_fn:
				temp = [line.split(',') for line in open(vmrk_fn).read().split('\n')]
				vmrk= [line for line in temp if line[0][:len('Mk')] == 'Mk']
				self.vmrk.append( vmrk )
		else:
			self.vmrk = None
			

	def make_events(self,vmrk):
		# creates an np array from vmrk list
		# called by vmrk2events expects raw vmrk list
		if not self.pp_id or not self.exp_type or not self.vmrk:
			self.events = None
		output = []
		for line in vmrk:
			if line[1]:
				event_id = int(line[1].strip('S').strip(' '))
				sample_number = int(line[2])
				output.append([sample_number,0,event_id])
		np_out = np.asarray(output)	
		return np_out


	def vmrk2events(self):
		# creates an np array events from 1 or more vmrk lists
		if not self.vmrk:
			print('Could not create events array, vmrk == None')
			return None
		print('Creating events array:\t sample_number , 0 , marker')
		if self.n_eeg_recordings == 1:
			self.events = self.make_events(self.vmrk)
		else:
			self.events = []
			self.events = [self.make_events(vmrk) for vmrk in self.vmrk]
			

	def vmrk2dict(self):
		# creates a dict with markers as keys and sample numbers as values
		if not self.vmrk:
			print('Could not create marker dict, self.vmrk == None')
			return None
		print("Creating marker_dict:\t marker -> sample number")
		if self.n_eeg_recordings == 1:
			events = self.events.tolist() 
			self.marker_dict = dict([[l[2],l[0]] for l in events])
		else:
			self.marker_dict = []
			for events in self.events:
				events = events.tolist()
				self.marker_dict.append( dict([[l[2],l[0]] for l in events]) )
				 
